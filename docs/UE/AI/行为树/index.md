---
categories: []
subtitle: 
draft: false
pin: false
title: index
date : 2025-05-05
---

## 行为树特性

**事件触发**：  
在传统的行为树中，如果要实现打断行为，就要在Tick整颗树的时候，不断的去判断`Decorator`节点是否已经满足打断条件，如果满足，则执行打断

**并行**：Service节点  
`Service` 节点的特点是，依附在 `Composite` / `Task` 节点上做伴随执行，不关心返回值，可以自定义更新时钟频率。

**条件节点非叶子节点**：

## 节点类型

充当行为树起始点的节点即 **根节点**。

它是整个行为树内的一个独特节点，因此拥有一些特殊规则。它只能有一个连接，且不支持附接 [[装饰器节点]] 或 [[服务节点]]。

尽管根节点没有自己的属性，但选中它会在 **详细信息（Details）** 面板中显示 **行为树（Behavior Tree）** 的属性，可以在该面板中设置行为树的 **黑板资源（Blackboard Asset）**。

| 节点类型      | 说明                                                                        |
| --------- | ------------------------------------------------------------------------- |
| [[复合节点]]  | 此类节点定义分支的根以及执行该分支的基本规则。                                                   |
| [[任务节点]]  | 此类节点是行为树的叶。它们是可执行的操作，没有输出连接。                                              |
| [[装饰器节点]] | 也称为条件。它们连接到另一节点，并决定树中的分支、甚至单个节点能否被执行。                                     |
| [[服务节点]]  | 此类节点附接至合成节点，而且只要其分支正在执行，它们就会按照定义的频率执行。它们通常用于检查和更新黑板。它们取代了其他行为树系统中的传统并行节点。 |

## 实例化规则

行为树节点作为共享对象存在，这意味着使用同一行为树的所有代理将共享一组节点实例。这样不仅可以在降低内存使用率的同时提升CPU性能，还可以防止节点保存代理特定的数据。不过，对于代理需要存储和更新节点相关信息的情况，虚幻引擎提供了以下三种解决方案：

### 实例化节点

将节点的 `bCreateNodeInstance` 变量设为 `true` 后，将使每个使用行为树的代理成为特殊的节点实例，以牺牲一定性能和内存使用率为代价来确保安全存储代理专属的数据。包括 `UBTTask_BlueprintBase`、`UBTTask_PlayAnimation`、`UBTTask_RunBehaviorDynamic` 在内的部分虚幻引擎节点类均使用此功能。

### 存储在黑板上

常见的解决方案是将变量存储在黑板上。执行此操作的方法是从节点公开变量命名，然后在节点初始化过程中使用该命名获取和存储黑板键。然后便可以使用黑板键在代理的黑板实例上获取并设置该变量的值。此方法支持 `bool`、`float`、`FVector`、`int32`、`enum`（存储为 `uint8`）、`UObject*` 类型的变量。

### 存储在行为树节点上

可以创建自定义结构体或类，将变量存储在节点的内存中。

## Reference

[Site Unreachable](https://zhuanlan.zhihu.com/p/143298443)
